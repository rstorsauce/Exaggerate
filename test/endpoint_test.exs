defmodule ExaggerateTest.EndpointTest do
  use ExUnit.Case

  @moduletag :one

  alias Exaggerate.Endpoint
  alias Exaggerate.AST

  describe "testing endpoint generating defs" do
    test "endpoint block with no parameters works" do
      blockcode_res = """
      def testblock(conn) do
        # autogen function.
        # insert your code here, then delete
        # the next exception:
        raise "error: testblock not implemented"
      end
      """

      assert blockcode_res == :testblock
      |> Endpoint.block(%Endpoint{params: []})
      |> AST.to_string
    end

    test "endpoint block with one parameter works" do
      blockcode_res = """
      def testblock(conn, param1) do
        # autogen function.
        # insert your code here, then delete
        # the next exception:
        raise "error: testblock not implemented"
      end
      """

      assert blockcode_res == :testblock
      |> Endpoint.block(%Endpoint{params: [:param1]})
      |> AST.to_string
    end

    test "endpoint block with two parameters works" do
      blockcode_res = """
      def testblock(conn, param1, param2) do
        # autogen function.
        # insert your code here, then delete
        # the next exception:
        raise "error: testblock not implemented"
      end
      """

      assert blockcode_res == :testblock
      |> Endpoint.block(%Endpoint{params: [:param1, :param2]})
      |> AST.to_string
    end
  end

  @one_def_module """
  #
  # NB. this file is autogenerated, altering the structure or arrangement
  # of the modules in this file can cause problems.
  #
  defmodule ModuleTestWeb.Endpoint do
    def testblock1(conn) do
      # autogen function.
      # insert your code here, then delete
      # the next exception:
      raise "error: testblock1 not implemented"
    end
  end
  """

  @two_def_module """
  #
  # NB. this file is autogenerated, altering the structure or arrangement
  # of the modules in this file can cause problems.
  #
  defmodule ModuleTestWeb.Endpoint do
    def testblock1(conn) do
      # autogen function.
      # insert your code here, then delete
      # the next exception:
      raise "error: testblock1 not implemented"
    end

    def testblock2(conn, param) do
      # autogen function.
      # insert your code here, then delete
      # the next exception:
      raise "error: testblock2 not implemented"
    end
  end
  """

  describe "testing endpoint generating modules" do
    test "endpoint module works with one def in the module" do
      assert @one_def_module == "module_test"
      |> Endpoint.module(%{testblock1: %Endpoint{params: []}})
      |> AST.to_string
    end

    test "endpoint module works with two defs in the module" do
      assert @two_def_module == "module_test"
      |> Endpoint.module(%{testblock1: %Endpoint{params: []},
                           testblock2: %Endpoint{params: [:param]}})
      |> AST.to_string
    end
  end

  def random_file do
    filename = [?0..?9, ?a..?z, ?A..?Z]
    |> Enum.concat
    |> Enum.take_random(16)
    |> List.to_string
    |> String.replace_suffix("", ".dat")
    Path.join("/tmp/", filename)
  end

  describe "features to do update" do
    test "can count implemented endpoints" do
      assert [:testblock1] == Endpoint.list_endpoints(@one_def_module)
      assert [:testblock1, :testblock2] == Endpoint.list_endpoints(@two_def_module)
    end

    test "can count implemented endpoints from file" do
      onedef_file = random_file()
      File.write!(onedef_file, @one_def_module)
      assert [:testblock1] == Endpoint.list_file_endpoints(onedef_file)

      twodef_file = random_file()
      File.write!(twodef_file, @two_def_module)
      assert [:testblock1, :testblock2] == Endpoint.list_file_endpoints(twodef_file)
    end
  end

  describe "updating files" do
    test "update an existing file" do
      onedef_file = random_file()
      File.write!(onedef_file, @one_def_module)
      update_map = %{
        testblock1: %Endpoint{params: []},
        testblock2: %Endpoint{params: [:param]}
      }
      Endpoint.update(onedef_file, update_map)
      assert @two_def_module == File.read!(onedef_file)
    end

    test "update an existing file with no changes changes nothing" do
      twodef_file = random_file()
      File.write!(twodef_file, @two_def_module)
      update_map = %{
        testblock2: [:param]
      }
      Endpoint.update(twodef_file, update_map)
      assert @two_def_module == File.read!(twodef_file)
    end
  end

end
